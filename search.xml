<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL语句优化</title>
      <link href="/2019/04/12/sql-yu-ju-you-hua/"/>
      <url>/2019/04/12/sql-yu-ju-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a><strong>SQL语句优化</strong></h1><p>怎么加快查询速度，优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引。</p><p>建立索引不是建的越多越好，原则是：</p><p>①、一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，<strong>一个表的索引最多不能超过6个，</strong>因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。</p><p>②、建立索引的方法论为：</p><pre class=" language-sh"><code class="language-sh">1. 多数查询经常使用的列；2. 很少进行修改操作的列；3. 索引需要建立在数据差异化大的列上</code></pre><h2 id="SQL优化分类"><a href="#SQL优化分类" class="headerlink" title="SQL优化分类"></a><strong>SQL优化分类</strong></h2><h3 id="1、sql语句模型结构优化指导"><a href="#1、sql语句模型结构优化指导" class="headerlink" title="1、sql语句模型结构优化指导"></a><strong>1、sql语句模型结构优化指导</strong></h3><h4 id="①、-ORDER-BY-LIMIT组合的索引优化"><a href="#①、-ORDER-BY-LIMIT组合的索引优化" class="headerlink" title="①、 ORDER BY + LIMIT组合的索引优化"></a><strong>①、 ORDER BY + LIMIT组合的索引优化</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--如果一个SQL语句形如</span><span class="token keyword">SELECT</span> <span class="token punctuation">[</span>column1<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>column2<span class="token punctuation">]</span><span class="token punctuation">,</span>…<span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token punctuation">[</span><span class="token keyword">TABLE</span><span class="token punctuation">]</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">[</span>sort<span class="token punctuation">]</span> <span class="token keyword">LIMIT</span> <span class="token punctuation">[</span><span class="token keyword">offset</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword">LIMIT</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。</span></code></pre><h4 id="②、-WHERE-ORDER-BY-LIMIT组合的索引优化"><a href="#②、-WHERE-ORDER-BY-LIMIT组合的索引优化" class="headerlink" title="②、 WHERE + ORDER BY + LIMIT组合的索引优化"></a><strong>②、 WHERE + ORDER BY + LIMIT组合的索引优化</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--如果一个SQL语句形如</span><span class="token keyword">SELECT</span> <span class="token punctuation">[</span>column1<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>column2<span class="token punctuation">]</span><span class="token punctuation">,</span>…<span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token punctuation">[</span><span class="token keyword">TABLE</span><span class="token punctuation">]</span> <span class="token keyword">WHERE</span> <span class="token punctuation">[</span>columnX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">VALUE</span><span class="token punctuation">]</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">[</span>sort<span class="token punctuation">]</span> <span class="token keyword">LIMIT</span> <span class="token punctuation">[</span><span class="token keyword">offset</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword">LIMIT</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)</span></code></pre><h4 id="③、WHERE-ORDER-BY多个栏位-LIMIT"><a href="#③、WHERE-ORDER-BY多个栏位-LIMIT" class="headerlink" title="③、WHERE+ORDER BY多个栏位+LIMIT"></a><strong>③、WHERE+ORDER BY多个栏位+LIMIT</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 如果一个SQL语句形如</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">[</span><span class="token keyword">table</span><span class="token punctuation">]</span> <span class="token keyword">WHERE</span> uid<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">ORDER</span> x<span class="token punctuation">,</span>y <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。</span></code></pre><h3 id="2、复合索引"><a href="#2、复合索引" class="headerlink" title="2、复合索引"></a><strong>2、复合索引</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--形如(x,y,uid)索引的索引</span><span class="token comment" spellcheck="true">--如果一个SQL语句形如</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users <span class="token keyword">where</span> area <span class="token operator">=</span>’beijing’ <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--如果我们是在area和age上分别创建索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果area，age两列上创建复合索引的话将带来更高的效率。</span><span class="token comment" spellcheck="true">--在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</span><span class="token comment" spellcheck="true">--例如我们建立了一个这样的索引（area,age,salary），那么其实相当于创建了（area,age,salary）,(area,age),(area)三个索引，这样称为最佳左前缀特性。</span></code></pre><h3 id="3、like语句优化"><a href="#3、like语句优化" class="headerlink" title="3、like语句优化"></a><strong>3、like语句优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> name <span class="token operator">like</span> <span class="token string">'%abc%'</span><span class="token comment" spellcheck="true">--由于abc前面用了“%”，因此该查询必然走全表查询，除非必要，否则不要在关键词前加%，优化成如下</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> name <span class="token operator">like</span> <span class="token string">'abc%'</span></code></pre><h3 id="4、where子句使用-！-或-lt-gt-操作符优化"><a href="#4、where子句使用-！-或-lt-gt-操作符优化" class="headerlink" title="4、where子句使用 ！= 或 &lt;&gt; 操作符优化"></a><strong>4、where子句使用 ！= 或 &lt;&gt; 操作符优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--在where子句中使用 ！= 或 &lt;>操作符，索引将被放弃使用，会进行全表查询。</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> ID <span class="token operator">!=</span> <span class="token number">5</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> ID<span class="token operator">></span><span class="token number">5</span> <span class="token operator">OR</span> ID<span class="token operator">&lt;</span><span class="token number">5</span></code></pre><h3 id="5、where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化"><a href="#5、where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化" class="headerlink" title="5、where子句中使用 IS NULL 或 IS NOT NULL 的优化"></a><strong>5、where子句中使用 IS NULL 或 IS NOT NULL 的优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--在where子句中使用 IS NULL 或 IS NOT NULL 判断，索引将被放弃使用，会进行全表查询。</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token comment" spellcheck="true">--优化成num上设置默认值0，确保表中num没有null值，</span>然后SQL为：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num<span class="token operator">=</span><span class="token number">0</span></code></pre><h3 id="6、where子句使用or的优化"><a href="#6、where子句使用or的优化" class="headerlink" title="6、where子句使用or的优化"></a><strong>6、where子句使用or的优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--很多时候使用union all 或 nuin(必要的时候)的方式替换“or”会得到更好的效果。</span><span class="token comment" spellcheck="true">--where子句中使用了or,索引将被放弃使用。</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">=</span><span class="token number">10</span> <span class="token operator">or</span> num <span class="token operator">=</span> <span class="token number">20</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num<span class="token operator">=</span><span class="token number">20</span></code></pre><h3 id="7、where子句使用IN-或-NOT-IN的优化"><a href="#7、where子句使用IN-或-NOT-IN的优化" class="headerlink" title="7、where子句使用IN 或 NOT IN的优化"></a><strong>7、where子句使用IN 或 NOT IN的优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--in和not in 也要慎用，否则也会导致全表扫描。</span><span class="token comment" spellcheck="true">--方案一：between替换in</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span><span class="token comment" spellcheck="true">--方案二：exist替换in</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> <span class="token number">b</span> <span class="token punctuation">)</span> 优化成：<span class="token keyword">SELECT</span> num <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> B <span class="token keyword">where</span> B<span class="token punctuation">.</span>num <span class="token operator">=</span> A<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--方案三：left join替换in</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> B<span class="token punctuation">)</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span>num <span class="token operator">=</span> B<span class="token punctuation">.</span>num</code></pre><h3 id="8、where子句中对字段进行表达式操作的优化"><a href="#8、where子句中对字段进行表达式操作的优化" class="headerlink" title="8、where子句中对字段进行表达式操作的优化"></a><strong>8、where子句中对字段进行表达式操作的优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--不要在where子句中的“=”左边进行函数、算数运算或其他表达式运算，否则系统将可能无法正确使用索引。</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">100</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token operator">*</span><span class="token number">2</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> substring<span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'abc'</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> <span class="token operator">LIKE</span> <span class="token string">'abc%'</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> datediff<span class="token punctuation">(</span>day<span class="token punctuation">,</span>createdate<span class="token punctuation">,</span><span class="token string">'2016-11-30'</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> createdate<span class="token operator">>=</span><span class="token string">'2016-11-30'</span> <span class="token operator">and</span> createdate<span class="token operator">&lt;</span><span class="token string">'2016-12-1'</span>如SQL:<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> year<span class="token punctuation">(</span>addate<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">2016</span> 优化成：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">where</span> addate<span class="token operator">&lt;</span><span class="token string">'2016-01-01'</span></code></pre><h3 id="9、尽量避免select-from"><a href="#9、尽量避免select-from" class="headerlink" title="9、尽量避免select * from　"></a><strong>9、尽量避免select * from</strong>　</h3><pre class=" language-sql"><code class="language-sql">任何地方都不要用 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> ，用具体的字段列表替换 <span class="token string">"*"</span>，不要返回用不到的字段</code></pre><h3 id="10、使用“临时表”暂存中间结果"><a href="#10、使用“临时表”暂存中间结果" class="headerlink" title="10、使用“临时表”暂存中间结果"></a><strong>10、使用“临时表”暂存中间结果</strong></h3><pre class=" language-sh"><code class="language-sh">采用临时表暂存中间结果好处：1）避免程序中多次扫描主表，减少程序执行“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。2）尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。3）避免频繁创建和删除临时表，以减少系统资源的浪费。4）尽量避免向客户端返回大数据量，若数据量过大，应考虑相应需求是否合理。</code></pre><h3 id="11、limit分页优化"><a href="#11、limit分页优化" class="headerlink" title="11、limit分页优化"></a><strong>11、limit分页优化</strong></h3><pre class=" language-sql"><code class="language-sql">当偏移量特别时，<span class="token keyword">limit</span>效率会非常低<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">LIMIT</span> <span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">10</span>   很快<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token keyword">LIMIT</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">10</span> 很慢<span class="token comment" spellcheck="true">--优化方法：</span>方法一：<span class="token keyword">select</span> id <span class="token keyword">from</span> A <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span> 很快，<span class="token number">0.04</span>秒就OK。 因为用了id主键做索引当然快方法二：<span class="token keyword">select</span> id<span class="token punctuation">,</span>title <span class="token keyword">from</span> A <span class="token keyword">where</span> id<span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> collect <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>方法三：<span class="token keyword">select</span> id <span class="token keyword">from</span> A <span class="token keyword">order</span> <span class="token keyword">by</span> id  <span class="token operator">between</span> <span class="token number">10000000</span> <span class="token operator">and</span> <span class="token number">10000010</span><span class="token punctuation">;</span></code></pre><h3 id="12、批量插入优化"><a href="#12、批量插入优化" class="headerlink" title="12、批量插入优化"></a><strong>12、批量插入优化</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">into</span> person<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> person<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> person<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--可优化为：</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> person<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span></code></pre><h3 id="13、利用limit-1-、top-1-取得一行"><a href="#13、利用limit-1-、top-1-取得一行" class="headerlink" title="13、利用limit 1 、top 1 取得一行"></a><strong>13、利用limit 1 、top 1 取得一行</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--有时要查询一张表时，你知道只需要看一条记录，你可能去查询一条特殊的记录。可以使用limit 1 或者 top 1 来终止数据库索引继续扫描整个表或索引。</span>如SQL：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token operator">LIKE</span> <span class="token string">'abc%'</span> 优化为：<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> A <span class="token operator">LIKE</span> <span class="token string">'abc%'</span> <span class="token keyword">limit</span> <span class="token number">1</span></code></pre><h3 id="14、尽量不要使用-BY-RAND-命令"><a href="#14、尽量不要使用-BY-RAND-命令" class="headerlink" title="14、尽量不要使用 BY RAND()命令"></a><strong>14、尽量不要使用 BY RAND()命令</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- BY RAND()是随机显示结果，这个函数可能会为表中每一个独立的行执行BY RAND()命令，这个会消耗处理器的处理能力。</span>如SQL：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">order</span> <span class="token keyword">by</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span> 优化为：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> id <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> A<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> RAND<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> A<span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span></code></pre><h3 id="15、排序的索引问题"><a href="#15、排序的索引问题" class="headerlink" title="15、排序的索引问题　"></a><strong>15、排序的索引问题</strong>　</h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--Mysql查询只是用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。</span><span class="token comment" spellcheck="true">--因此数据库默认排序可以符合要求情况下不要使用排序操作；</span><span class="token comment" spellcheck="true">--尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</span></code></pre><h3 id="16、尽量用-union-add-替换-union"><a href="#16、尽量用-union-add-替换-union" class="headerlink" title="16、尽量用 union add 替换 union"></a><strong>16、尽量用 union add 替换 union</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。</span><span class="token comment" spellcheck="true">--所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union</span></code></pre><h3 id="17、避免类型转换"><a href="#17、避免类型转换" class="headerlink" title="17、避免类型转换"></a><strong>17、避免类型转换</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换。人为的上通过转换函数进行转换，直接导致mysql无法使用索引。如果非要转型，应该在传入参数上进行转换。</span>例如 utime 是 <span class="token keyword">datetime</span> 类型，传入的参数是 “ <span class="token number">2016</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">23</span> ”在比较大小时通常是 <span class="token keyword">date</span>（utime）<span class="token operator">></span><span class="token string">"2016-07-23"</span>可以优化为utime<span class="token operator">></span><span class="token string">"2016-07-23 00：00：00"</span></code></pre><h3 id="18、尽可能使用更小的字段"><a href="#18、尽可能使用更小的字段" class="headerlink" title="18、尽可能使用更小的字段　"></a><strong>18、尽可能使用更小的字段</strong>　</h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I/O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。</span><span class="token comment" spellcheck="true">--修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。　</span></code></pre><h3 id="19、Inner-join-和-left-join、right-join、子查询"><a href="#19、Inner-join-和-left-join、right-join、子查询" class="headerlink" title="19、Inner join 和 left join、right join、子查询"></a><strong>19、Inner join 和 left join、right join、子查询</strong></h3><h4 id="第一：inner-join内连接也叫等值连接，left-right-join是外连接。"><a href="#第一：inner-join内连接也叫等值连接，left-right-join是外连接。" class="headerlink" title="第一：inner join内连接也叫等值连接，left/right join是外连接。"></a><strong>第一：inner join内连接也叫等值连接，left/right join是外连接。</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span>A<span class="token punctuation">.</span>name<span class="token punctuation">,</span>B<span class="token punctuation">.</span>id<span class="token punctuation">,</span>B<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> A <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span>B<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span>A<span class="token punctuation">.</span>name<span class="token punctuation">,</span>B<span class="token punctuation">.</span>id<span class="token punctuation">,</span>B<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> A <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> <span class="token keyword">ON</span> B A<span class="token punctuation">.</span>id<span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span>A<span class="token punctuation">.</span>name<span class="token punctuation">,</span>B<span class="token punctuation">.</span>id<span class="token punctuation">,</span>B<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> A <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token keyword">ON</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span>B<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--经过来之多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</span><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span>A<span class="token punctuation">.</span>name<span class="token punctuation">,</span>B<span class="token punctuation">.</span>id<span class="token punctuation">,</span>B<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> A<span class="token punctuation">,</span>B <span class="token keyword">WHERE</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--推荐：能用 inner join 连接尽量使用 inner join 连接</span></code></pre><h4 id="第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。"><a href="#第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。" class="headerlink" title="第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。"></a><strong>第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">Select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">where</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> B <span class="token keyword">where</span> id<span class="token operator">>=</span><span class="token number">3000</span> <span class="token operator">and</span> A<span class="token punctuation">.</span>uuid<span class="token operator">=</span>B<span class="token punctuation">.</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--A表的数据为十万级表，B表为百万级表，在本机执行差不多用2秒左右，我们可以通过explain可以查看到子查询是一个相关子查询(DEPENDENCE SUBQUERY);Mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。</span><span class="token comment" spellcheck="true">--一种简单的优化就是用innerjoin的方法来代替子查询，查询语句改为：</span><span class="token keyword">Select</span><span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">inner</span> <span class="token keyword">join</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span>uuid<span class="token operator">=</span>B<span class="token punctuation">.</span>uuid <span class="token keyword">using</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token number">b</span><span class="token punctuation">.</span>uuid<span class="token operator">>=</span><span class="token number">3000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--这个语句执行测试不到一秒；</span><span class="token comment" spellcheck="true">--第三：使用JOIN时候，应该用小的结果join大的结果（left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向），同时尽量把牵涉到多表联合的查询拆分多个query</span><span class="token comment" spellcheck="true">--多个表查询效率低，容易锁表和阻塞</span><span class="token comment" spellcheck="true">--如：</span><span class="token keyword">Select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">left</span> <span class="token keyword">join</span> B A<span class="token punctuation">.</span>id<span class="token operator">=</span>B<span class="token punctuation">.</span>ref_id <span class="token keyword">where</span>  A<span class="token punctuation">.</span>id<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--可以优化为：</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A wehre id <span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span> T1 <span class="token keyword">left</span> <span class="token keyword">join</span> B <span class="token keyword">on</span> T1<span class="token punctuation">.</span>id<span class="token operator">=</span>B<span class="token punctuation">.</span>ref_id<span class="token punctuation">;</span></code></pre><h3 id="20、exist-代替-in"><a href="#20、exist-代替-in" class="headerlink" title="20、exist 代替 in"></a><strong>20、exist 代替 in</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">WHERE</span> idin <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">from</span> B<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">WHERE</span> id <span class="token keyword">EXISTS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">from</span> A<span class="token punctuation">.</span>id<span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--in 是在内存中遍历比较</span><span class="token comment" spellcheck="true">--exist 需要查询数据库，所以当B的数据量比较大时，exists效率优于in.</span><span class="token comment" spellcheck="true">--in()只执行一次，把B表中的所有id字段缓存起来，之后检查A表的id是否与B表中的id相等，如果id相等则将A表的记录加入到结果集中，直到遍历完A表的所有记录。</span><span class="token comment" spellcheck="true">--In 操作的流程原理如同一下代码</span>  List resultSet<span class="token operator">=</span>{}<span class="token punctuation">;</span>    Array A<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>    Array B<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> {            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>B<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> {          <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token operator">=</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> {             resultSet<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>          }       }    }    <span class="token keyword">return</span> resultSet<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--可以看出，当B表数据较大时不适合使用in()，因为它会B表数据全部遍历一次</span><span class="token comment" spellcheck="true">--如：A表有10000条记录，B表有1000000条记录，那么最多有可能遍历10000*1000000次，效率很差。</span><span class="token comment" spellcheck="true">--再如：A表有10000条记录，B表有100条记录，那么最多有可能遍历10000*100次，遍历次数大大减少，效率大大提升。</span><span class="token comment" spellcheck="true">--结论：in()适合B表比A表数据小的情况</span><span class="token comment" spellcheck="true">--exist()会执行A.length()次，执行过程代码如下</span>    List resultSet<span class="token operator">=</span>{}<span class="token punctuation">;</span>    Array A<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> {       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">exists</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> {  <span class="token comment" spellcheck="true">//执行select 1 from B where B.id=A.id是否有记录返回</span>           resultSet<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       }    }    <span class="token keyword">return</span> resultSet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--当B表比A表数据大时适合使用exists()，因为它没有那么多遍历操作，只需要再执行一次查询就行。</span><span class="token comment" spellcheck="true">--如：A表有10000条记录，B表有1000000条记录，那么exists()会执行10000次去判断A表中的id是否与B表中的id相等。</span><span class="token comment" spellcheck="true">--如：A表有10000条记录，B表有100000000条记录，那么exists()还是执行10000次，因为它只执行A.length次，可见B表数据越多，越适合exists()发挥效果。</span><span class="token comment" spellcheck="true">--再如：A表有10000条记录，B表有100条记录，那么exists()还是执行10000次，还不如使用in()遍历10000*100次，因为in()是在内存里遍历比较，而exists()需要查询数据库，</span><span class="token comment" spellcheck="true">--我们都知道查询数据库所消耗的性能更高，而内存比较很快。</span><span class="token comment" spellcheck="true">--结论：exists()适合B表比A表数据大的情况</span><span class="token comment" spellcheck="true">--当A表数据与B表数据一样大时，in与exists效率差不多，可任选一个使用。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL综合优化</title>
      <link href="/2019/04/11/sql-zong-he-you-hua/"/>
      <url>/2019/04/11/sql-zong-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL如何实现优化？"><a href="#MySQL如何实现优化？" class="headerlink" title="MySQL如何实现优化？"></a><strong>MySQL如何实现优化？</strong></h2><h3 id="1、数据库设计要合理（3F）"><a href="#1、数据库设计要合理（3F）" class="headerlink" title="1、数据库设计要合理（3F）"></a>1、<strong>数据库设计要合理</strong>（3F）</h3><h4 id="1F-原子约束"><a href="#1F-原子约束" class="headerlink" title="1F 原子约束"></a>1F <strong>原子约束</strong></h4><p>当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。简单的来说就是列无法再进行分割。</p><p> ①、每一列属性都是不可再分的属性值，确保每一列的原子性</p><p> ②、两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</p><h4 id="2F保证唯一性"><a href="#2F保证唯一性" class="headerlink" title="2F保证唯一性"></a>2F<strong>保证唯一性</strong></h4><p>主键 （不能用id作为订单号码，订单号码利用分布式锁提前将订单号生成好，存放在redis中，需要的话直接去redis中获取 ）</p><p>每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</p><h4 id="3F不要有冗余数据"><a href="#3F不要有冗余数据" class="headerlink" title="3F不要有冗余数据"></a>3F<strong>不要有冗余数据</strong></h4><p>id    name    address    classid    classname</p><p>1    a        北京        1        chinese</p><p>2    b        北京        2        math</p><p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p><p>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</p><p>这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)</p><p>这样的表结构，我们应该拆开来，如下。</p><p>（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p><h3 id="2、添加索引"><a href="#2、添加索引" class="headerlink" title="2、添加索引"></a>2、<strong>添加索引</strong></h3><h5 id="①索引的定义"><a href="#①索引的定义" class="headerlink" title="①索引的定义"></a><strong>①索引的定义</strong></h5><p>　　数据库索引好比是一本书前面的目录，能加快数据库的查询速度。<a href="http://baike.baidu.com/view/262241.htm" target="_blank" rel="noopener">索引</a>是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p><h5 id="②建立索引的优缺点："><a href="#②建立索引的优缺点：" class="headerlink" title="②建立索引的优缺点："></a><strong>②建立索引的优缺点：</strong></h5><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h6><p>​    1.大大加快数据的检索速度;<br>​    2.创建唯一性索引，保证数据库表中每一行数据的唯一性;<br>​    3.加速表和表之间的连接;<br>​    4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</p><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h6><p>　　1.索引需要占用数据表以外的物理存储空间</p><p>　　2.创建索引和维护索引要花费一定的时间</p><p>　　3.当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</p><h5 id="③、索引类型"><a href="#③、索引类型" class="headerlink" title="③、索引类型"></a><strong>③、索引类型</strong></h5><p>索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</p><h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a><strong>主键索引</strong>：</h6><p>primary key    数据库表经常有一列或列组合，其值唯一标识表中的每一行，该列称为表的主键。   在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 </p><h6 id="唯一索引："><a href="#唯一索引：" class="headerlink" title="唯一索引："></a><strong>唯一索引</strong>：</h6><p>UNIQUE   表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。</p><h6 id="普通索引："><a href="#普通索引：" class="headerlink" title="普通索引："></a><strong>普通索引：</strong></h6><p>这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。</p><h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a><strong>全文索引</strong></h6><p>FULLTEXT    索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。</p><h6 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a><strong>组合索引</strong></h6><p>平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：</p><h4 id="MySQL的数据结构"><a href="#MySQL的数据结构" class="headerlink" title="MySQL的数据结构"></a><strong>MySQL的数据结构</strong></h4><h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a><strong>B树</strong></h5><p>B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化<strong>大块数据的读和写操作</strong>。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在<strong>数据库</strong>和<strong>文件系统</strong>。”</p><p><strong>B 树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点</li></ul><p>下图是一个M=4 阶的B树:</p><p><img src="/images/MySQL优化/11.png" alt=""></p><p>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。</p><p>B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入</p><p><strong>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</strong>     的演示动画：</p><p><img src="/images/MySQL优化/12.gif" alt=""></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a><strong>B+树</strong></h5><p>​    我们经常听到B+树就是这个概念，用这个树的目的和红黑树差不多，也是为了尽量保持树的平衡，当然红黑树是二叉树，但B+树就不是二叉树了，节点下面可以有多个子节点，数据库开发商会设置子节点数的一个最大值，这个值不会太小，所以B+树一般来说比较矮胖，而红黑树就比较瘦高了。<br>关于B+树的插入，删除，会涉及到一些算法以保持树的平衡，这里就不详述了。ORACLE的默认索引就是这种结构的。<br>如果经常需要同时对两个字段进行AND查询,那么使用两个单独索引不如建立一个复合索引，因为两个单独索引通常数据库只能使用其中一个，而使用复合索引因为索引本身就对应到两个字段上的，效率会有很大提高。</p><p><strong>B+</strong>树是对B树的一种变形树，它与B树的差异在于：</p><ul><li>有k个子结点的结点必然有k个关键码；</li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li></ul><p>如下图，是一个B+树:</p><p><img src="/images/MySQL优化/8.png" alt="B+树"></p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="/images/MySQL优化/9.gif" alt="实现过程"></h6><h3 id="3、分表分库技术"><a href="#3、分表分库技术" class="headerlink" title="3、分表分库技术"></a>3、<strong>分表分库技术</strong></h3><p>取模分表、水平分割、垂直分割</p><h4 id="什么是分库分表？"><a href="#什么是分库分表？" class="headerlink" title="什么是分库分表？"></a><strong>什么是分库分表</strong>？</h4><p>顾名思义，分库分表就是按照一定的规则，对原有的数据库和表进行拆分，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。</p><h4 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a><strong>为什么要分库分表</strong>？</h4><p>随着时间和业务的发展，数据库中的数据量增长是不可控的，库和表中的数据会越来越大，随之带来的是更高的磁盘、IO、系统开销，甚至性能上的瓶颈，而一台服务的资源终究是有限的，因此需要对数据库和表进行拆分，从而更好的提供数据服务。</p><p>可以用说用到MySQL的地方,只要数据量一大, 马上就会遇到一个问题,要分库分表. 这里引用一个问题为什么要分库分表呢?MySQL处理不了大的表吗? 其实是可以处理的大表的.我所经历的项目中单表物理上文件大小在80G多,单表记录数在5亿以上,而且这个表 属于一个非常核用的表:朋友关系表. </p><p>但这种方式可以说不是一个最佳方式. 因为面临文件系统如Ext3文件系统对大于大文件处理上也有许多问题. 这个层面可以用xfs文件系统进行替换.但MySQL单表太大后有一个问题是不好解决: 表结构调整相关的操作基<br>本不在可能.所以大项在使用中都会面监着分库分表的应用. </p><p>从Innodb本身来讲数据文件的Btree上只有两个锁, 叶子节点锁和子节点锁,可以想而知道,当发生页拆分或是添加新叶时都会造成表里不能写入数据.所以分库分表还就是一个比较好的选择了. </p><h4 id="怎么分库分表合适呢"><a href="#怎么分库分表合适呢" class="headerlink" title="怎么分库分表合适呢?"></a><strong>怎么分库分表合适呢</strong>?</h4><p>经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数据字型的保持在800万条记录以下, 有字符型的单表保持在500万以下. </p><p>如果按 100库100表来规划,如用户业务: 500万<em>100</em>100 = 50000000万 = 5000亿记录. </p><p>心里有一个数了,按业务做规划还是比较容易的.</p><p>分布式数据库架构–排序、分页、分组、实现</p><h4 id="什么时候分库？"><a href="#什么时候分库？" class="headerlink" title="什么时候分库？"></a><strong>什么时候分库</strong>？</h4><p>电商项目将一个项目进行拆分，拆成多个小项目，每个小项目都有自己单独的数据库，互不影响（垂直分割订单数据库）</p><h4 id="什么时候分表？"><a href="#什么时候分表？" class="headerlink" title="什么时候分表？"></a><strong>什么时候分表</strong>？</h4><p>对于某网站平台的数据库表-公司表，数据量很大，这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。</p><h4 id="为什么分表？"><a href="#为什么分表？" class="headerlink" title="为什么分表？"></a><strong>为什么分表</strong>？</h4><p>当一张表的数据达到几千万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。</p><p>某网站现在的数据量至多是5000万条，可以设计每张表容纳的数据量是500万条，也就是拆分成10张表，</p><p>那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当&lt;500万条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作。</p><h5 id="垂直分库-分表"><a href="#垂直分库-分表" class="headerlink" title="垂直分库/分表"></a><strong>垂直分库</strong>/分表</h5><p>如果把业务切割得足够独立，那把不同业务的数据放到不同的数据库服务器将是一个不错的方案，而且万一其中一个业务崩溃了也不会影响其他业务的正常进行，并且也起到了负载分流的作用，大大提升了数据库的吞吐能力。经过垂直分区后的数据库架构图如下：</p><p><img src="/images/MySQL优化/1.jpg" alt=""></p><p>然而，尽管业务之间已经足够独立了，但是有些业务之间或多或少总会有点联系，如用户，基本上都会和每个业务相关联，况且这种分区方式，也不能解决单张表数据量暴涨的问题，因此可以尝试水平分割</p><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h6><ol><li>拆分后业务清晰，达到专库专用。</li><li>可以实现热数据和冷数据的分离，将不经常变化的数据和变动较大的数据分散再不同的库/表中。</li><li>便于维护</li></ol><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点：</strong></h6><ol><li>不解决数据量大带来的性能损耗，读写压力依旧很大</li><li>不同的业务无法跨库关联（join），只能通过业务来关联</li></ol><h5 id="水平分库-分表"><a href="#水平分库-分表" class="headerlink" title="水平分库/分表"></a><strong>水平分库/分表</strong></h5><p>这是一个非常好的思路，将用户按一定规则（按id哈希）分组，并把该组用户的数据存储到一个数据库分片中，即一个sharding，这样随着用户数量的增加，只要简单地配置一台服务器即可，原理图如下：</p><p><img src="/images/MySQL优化/2.jpg" alt=""></p><p>如何来确定某个用户所在的shard呢，可以建一张用户和shard对应的数据表，每次请求先从这张表找用户的shard id，再从对应shard中查询相关数据，如下图所示：</p><p><img src="/images/MySQL优化/3.jpg" alt=""></p><h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a><strong>优点：</strong></h6><ol><li>单库（表）的数据量得以减少，提高性能</li><li>提高了系统的稳定性和负载能力</li><li>切分出的表结构相同，程序改动较少</li></ol><h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a><strong>缺点：</strong></h6><ol><li>拆分规则较难抽象</li><li>数据分片在扩容时需要迁移</li><li>维护量增大</li><li>依然存在跨库无法join等问题，同时涉及分布式事务，数据一致性等问题。</li></ol><h4 id="分库-分表分类"><a href="#分库-分表分类" class="headerlink" title="分库/分表分类"></a><strong>分库/分表分类</strong></h4><h5 id="单库单表"><a href="#单库单表" class="headerlink" title="单库单表"></a><strong>单库单表</strong></h5><p>单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。 </p><h5 id="单库多表"><a href="#单库多表" class="headerlink" title="单库多表"></a><strong>单库多表</strong></h5><p>随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 </p><p>可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 </p><h5 id="多库多表"><a href="#多库多表" class="headerlink" title="多库多表"></a><strong>多库多表</strong></h5><p>随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 </p><h4 id="分库分表规则"><a href="#分库分表规则" class="headerlink" title="分库分表规则"></a><strong>分库分表规则</strong></h4><p> 设计表的时候需要确定此表按照什么样的规则进行分库分表。例如，当有新用户时，程序得确定将此用户信息添加到哪个表中；同理，当登录的时候我们得通过用户的账号找到数据库中对应的记录，所有的这些都需要按照某一规则进行。<br>路由 </p><p>通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id mod 4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id mod 4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 mod 4后确定记录在User_0003中。 </p><h4 id="分库分表产生的问题，及注意事项"><a href="#分库分表产生的问题，及注意事项" class="headerlink" title="分库分表产生的问题，及注意事项"></a><strong>分库分表产生的问题，及注意事项</strong></h4><h5 id="分库分表维度的问题"><a href="#分库分表维度的问题" class="headerlink" title="分库分表维度的问题"></a><strong>分库分表维度的问题</strong></h5><p>假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的 购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找 到买人的交易记录比较麻烦。 </p><p>所以常见的解决方式有： </p><ul><li>通过扫表的方式解决，此方法基本不可能，效率太低了。</li><li>记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。</li><li>通过搜索引擎解决，但如果实时性要求很高，又得关系到实时搜索。 </li></ul><h5 id="联合查询的问题"><a href="#联合查询的问题" class="headerlink" title="联合查询的问题"></a><strong>联合查询的问题</strong></h5><p>联合查询基本不可能，因为关联的表有可能不在同一数据库中。 </p><h5 id="避免跨库事务"><a href="#避免跨库事务" class="headerlink" title="避免跨库事务"></a><strong>避免跨库事务</strong></h5><p>避免在一个事务中修改db0中的表的时候同时修改db1中的表，一个是操作起来更复杂，效率也会有一定影响。 </p><h5 id="尽量把同一组数据放到同一DB服务器上"><a href="#尽量把同一组数据放到同一DB服务器上" class="headerlink" title="尽量把同一组数据放到同一DB服务器上"></a><strong>尽量把同一组数据放到同一</strong>DB服务器上</h5><p>例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。 </p><h5 id="一主多备"><a href="#一主多备" class="headerlink" title="一主多备"></a><strong>一主多备</strong></h5><p>在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.                                                       </p><p>所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。<br>此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。<br>所以</p><ul><li>当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。</li><li>当写压力很大的时候，就必须得进行分库操作。 </li></ul><h3 id="4、读写分离"><a href="#4、读写分离" class="headerlink" title="4、读写分离"></a><strong>4、读写分离</strong></h3><p>MySQL的主从复制解决了数据库的读写分离，并很好的提升了读的性能</p><p><img src="/images/MySQL优化/4.jpg" alt=""></p><p>其主从复制的过程如下图所示：</p><p><img src="/images/MySQL优化/5.jpg" alt=""></p><p>主从复制也带来其他一系列性能瓶颈问题：</p><ol><li>写入无法扩展</li><li>写入无法缓存</li><li>复制延时</li><li>锁表率上升</li><li>表变大，缓存率下降</li></ol><h5 id="使用Sharding-JDBC进行分库分表"><a href="#使用Sharding-JDBC进行分库分表" class="headerlink" title="使用Sharding-JDBC进行分库分表"></a><strong>使用Sharding-JDBC进行分库分表</strong></h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h6><p>Sharding-JDBC是一个开源的分布式数据库中间件，它无需额外部署和依赖，完全兼容JDBC和各种ORM框架。Sharding-JDBC作为面向开发的微服务云原生基础类库，完整的实现了分库分表、读写分离和分布式主键功能，并初步实现了柔性事务。关于sj的详细配置和使用方法请参见<a href="https://link.jianshu.com?t=http%3A%2F%2Fshardingsphere.io%2Fdocs_cn%2F00-overview%2F" target="_blank" rel="noopener">官方文档</a></p><h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h6><p>Sharing-JDBC的springboot starter对springboot 2.0还不支持。我也是配置完项目启动失败才发现这个issue，懒得切换版本就暂且不使用starter pom吧，直接使用编程式配置。</p><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h6><p>本Demo中使用的两个数据源是db0和db1，每个数据源之中包含了两组表t_order_0和t_order_1，t_order_item_0和t_order_item_1 。和官方文档的demo一致，这两组表的建表语句为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> t_order_x <span class="token punctuation">(</span>  order_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  user_id  <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> t_order_item_x <span class="token punctuation">(</span>  item_id  <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  order_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  user_id  <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>item_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>逻辑结构如下：</p><pre class=" language-sh"><code class="language-sh">db0  ├── t_order_0   └── t_order_1 db1  ├── t_order_0   └── t_order_1</code></pre><p>首先引入依赖</p><pre><code>&lt;dependency&gt;       &lt;groupId&gt;io.shardingjdbc&lt;/groupId&gt;       &lt;artifactId&gt;sharding-jdbc-core&lt;/artifactId&gt;       &lt;version&gt;2.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置表分片策略</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Bean</span>    TableRuleConfiguration <span class="token function">getOrderTableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TableRuleConfiguration orderTableRuleConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//配置逻辑表名，并非数据库中真实存在的表名，而是sql中使用的那个，不受分片策略而改变.  </span>        <span class="token comment" spellcheck="true">//例如：select * frpm t_order where user_id = xxx</span>        orderTableRuleConfig<span class="token punctuation">.</span><span class="token function">setLogicTable</span><span class="token punctuation">(</span><span class="token string">"t_order"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//配置真实的数据节点，即数据库中真实存在的节点，由数据源名 + 表名组成</span>        <span class="token comment" spellcheck="true">//${} 是一个groovy表达式，[]表示枚举，{...}表示一个范围。  </span>        <span class="token comment" spellcheck="true">//整个inline表达式最终会是一个笛卡尔积，表示ds_0.t_order_0. ds_0.t_order_1</span>        <span class="token comment" spellcheck="true">// ds_1.t_order_0. ds_1.t_order_0</span>        orderTableRuleConfig<span class="token punctuation">.</span><span class="token function">setActualDataNodes</span><span class="token punctuation">(</span><span class="token string">"ds_${0..1}.t_order_${0..1}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//主键生成列，默认的主键生成算法是snowflake</span>        orderTableRuleConfig<span class="token punctuation">.</span><span class="token function">setKeyGeneratorColumnName</span><span class="token punctuation">(</span><span class="token string">"order_id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//设置分片策略，这里简单起见直接取模，也可以使用自定义算法来实现分片规则</span>        orderTableRuleConfig<span class="token punctuation">.</span><span class="token function">setTableShardingStrategyConfig</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InlineShardingStrategyConfiguration</span><span class="token punctuation">(</span><span class="token string">"order_id"</span><span class="token punctuation">,</span><span class="token string">"t_order_${order_id % 2}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> orderTableRuleConfig<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    TableRuleConfiguration <span class="token function">getOrderItemTableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TableRuleConfiguration orderItemTableRuleConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderItemTableRuleConfig<span class="token punctuation">.</span><span class="token function">setLogicTable</span><span class="token punctuation">(</span><span class="token string">"t_order_item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderItemTableRuleConfig<span class="token punctuation">.</span><span class="token function">setActualDataNodes</span><span class="token punctuation">(</span><span class="token string">"ds_${0..1}.t_order_item_${0..1}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderItemTableRuleConfig<span class="token punctuation">.</span><span class="token function">setTableShardingStrategyConfig</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InlineShardingStrategyConfiguration</span><span class="token punctuation">(</span><span class="token string">"order_item_id"</span><span class="token punctuation">,</span><span class="token string">"t_order_item_${order_id % 2}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> orderItemTableRuleConfig<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>配置数据源</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> DataSource<span class="token operator">></span> <span class="token function">createDataSourceMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> DataSource<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"ds_0"</span><span class="token punctuation">,</span> <span class="token function">createDataSource</span><span class="token punctuation">(</span><span class="token string">"ds_0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"ds_1"</span><span class="token punctuation">,</span> <span class="token function">createDataSource</span><span class="token punctuation">(</span><span class="token string">"ds_1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> DataSource <span class="token function">createDataSource</span><span class="token punctuation">(</span><span class="token keyword">final</span> String dataSourceName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DruidDataSource result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setInitialSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setMaxActive</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/%s?useSSL=false"</span><span class="token punctuation">,</span> dataSourceName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Bean</span>    DataSource <span class="token function">getShardingDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        ShardingRuleConfiguration shardingRuleConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShardingRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shardingRuleConfig<span class="token punctuation">.</span><span class="token function">getTableRuleConfigs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getOrderTableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shardingRuleConfig<span class="token punctuation">.</span><span class="token function">getTableRuleConfigs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getOrderItemTableRuleConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shardingRuleConfig<span class="token punctuation">.</span><span class="token function">getBindingTableGroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"t_order, t_order_item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shardingRuleConfig<span class="token punctuation">.</span><span class="token function">setDefaultDatabaseShardingStrategyConfig</span><span class="token punctuation">(</span>          <span class="token keyword">new</span> <span class="token class-name">InlineShardingStrategyConfiguration</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">,</span> <span class="token string">"ds_${user_id % 2}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shardingRuleConfig<span class="token punctuation">.</span><span class="token function">setDefaultTableShardingStrategyConfig</span><span class="token punctuation">(</span>          <span class="token keyword">new</span> <span class="token class-name">InlineShardingStrategyConfiguration</span><span class="token punctuation">(</span><span class="token string">"order_id"</span><span class="token punctuation">,</span> <span class="token string">"t_order_${order_id % 2}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ShardingDataSourceFactory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span><span class="token function">createDataSourceMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          shardingRuleConfig<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h6><p>使用junittest插入一条记录，查看分片结果：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderDaoTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span> <span class="token keyword">private</span> OrderDao orderDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Order order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//insert into t_order (order_id, user_id) values(#{orderId}, #{userId})</span>        orderDao<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>t_order这张表配置的分片策略是按照order_id与2取模，分库策略则是按照user_id与2取模，<br>所以最终的结果应该是插入在ds_1中的t_order_1中。</p><h3 id="5、存储过程"><a href="#5、存储过程" class="headerlink" title="5、存储过程"></a><strong>5、存储过程</strong></h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a><strong>介绍：</strong></h4><p>就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；</p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a><strong>优点</strong>：</h4><p>①、使用了存过程，很多相似性的删除，更新，新增等操作就变得轻松了，并且以后也便于管理！<br>②、存储过程因为SQL语句已经预编绎过了，因此运行的速度比较快。<br>③、存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值。可以向程序返回错误原因。<br>④、存储过程运行比较稳定，不会有太多的错误。只要一次成功，以后都会按这个程序运行。<br>⑤、存储过程主要是在服务器上运行，减少对客户机的压力。<br>⑥、存储过程可以包含程序流、逻辑以及对数据库的查询。同时可以实体封装和隐藏了数据逻辑。<br>⑦、存储过程可以在单个存储过程中执行一系列SQL语句。<br>⑧、存储过程可以从自己的存储过程内引用其它存储过程，这可以简化一系列复杂语句。</p><h3 id="6、配置MySQL最大连接数（my-ini配置）"><a href="#6、配置MySQL最大连接数（my-ini配置）" class="headerlink" title="6、配置MySQL最大连接数（my.ini配置）"></a><strong>6、配置MySQL最大连接数（my.ini配置）</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--查看最大连接数</span><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%max_connections%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--修改最大连接数</span><span class="token keyword">set</span> <span class="token keyword">GLOBAL</span> max_connections <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span></code></pre><h3 id="8、随时清理碎片"><a href="#8、随时清理碎片" class="headerlink" title="8、随时清理碎片"></a><strong>8、随时清理碎片</strong></h3><h4 id="产生的原因？"><a href="#产生的原因？" class="headerlink" title="产生的原因？"></a><strong>产生的原因？</strong></h4><p>①、表的存储会出现碎片化，每当删除了一行内容，该段空间就会变为空白、被留空，而在一段时间内的大量删除操作，会使这种留空的空间变得比存储列表内容所使用的空间更大；</p><p>②、当执行插入操作时，MySQL会尝试使用空白空间，但如果某个空白空间一直没有被大小合适的数据占用，仍然无法将其彻底占用，就形成了碎片；</p><p>③、当MySQL对数据进行扫描时，它扫描的对象实际是列表的容量需求上限，也就是数据被写入的区域中处于峰值位置的部分；</p><h4 id="如何处理？"><a href="#如何处理？" class="headerlink" title="如何处理？"></a><strong>如何处理？</strong></h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--查看表的碎片大小</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLE</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'表名'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--清除表的碎片（MyISAM）    </span><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> table_name；<span class="token comment" spellcheck="true">--清除表的碎片（InnoDB）</span> <span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span></code></pre><h3 id="9、SQL语句优化"><a href="#9、SQL语句优化" class="headerlink" title="9、SQL语句优化"></a><strong>9、SQL语句优化</strong></h3><h4 id="关键词的执行顺序"><a href="#关键词的执行顺序" class="headerlink" title="关键词的执行顺序"></a><strong>关键词的执行顺序</strong></h4><p><strong>写的顺序：</strong>select … from… where…. group by… having… order by.. limit [offset,]<br><strong>执行顺序：</strong>from… where…group by… having…. select … order by… limit</p><pre class=" language-sh"><code class="language-sh"> 下面具体分析一下查询处理的每一个阶段 1 RM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 2 ON: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。 3 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到            虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结           果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 4 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。 5 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. 6 CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. 7 HAVING： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。 8 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 9 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. 10 ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10. 11 LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</code></pre><p><strong>详细见SQL语句优化文档</strong></p><h3 id="10、执行计划"><a href="#10、执行计划" class="headerlink" title="10、执行计划**"></a>10、执行计划**</h3><h4 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a><strong>定位慢查询</strong></h4><h5 id="什么是慢查询？"><a href="#什么是慢查询？" class="headerlink" title="什么是慢查询？"></a><strong>什么是慢查询？</strong></h5><p>mysql默认sql语句在10S内没有返回，则被认为是慢查询</p><p>慢查询都有日志记录</p><p>使用show status查看mysql服务器状态信息</p><h5 id="命令："><a href="#命令：" class="headerlink" title="命令："></a><strong>命令：</strong></h5><p>查看数据库启动时间：show status like ‘uptime’;</p><p>显示数据可的查询、更新、添加、删除的次数：show status like ‘com_select’,……</p><p>显示数据库的连接数：show status like ‘connections’;</p><p>显示慢查询次数：show status like ‘slow_queries’;</p><p>默认情况mysql不会记录慢查询的日志</p><p> 步骤：停止mysql服务-&gt;进入mysql目录-&gt;进入cmd-&gt;输入 mysqld.exe –safe-mode –slow-query-log-&gt;不要关闭cmd界面</p><p>查看慢查询log日志：在mysql data目录中找log文件（可以在my.ini中找到目录位置）</p><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a><strong>索引优化</strong></h4><h5 id="①、何时使用聚集索引或非聚集索引？"><a href="#①、何时使用聚集索引或非聚集索引？" class="headerlink" title="①、何时使用聚集索引或非聚集索引？"></a><strong>①、何时使用聚集索引或非聚集索引？</strong></h5><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>使用</td><td>使用</td></tr><tr><td>返回某范围内的数据</td><td>使用</td><td>不使用</td></tr><tr><td>一个或极少不同值</td><td>不使用</td><td>不使用</td></tr><tr><td>小数目的不同值</td><td>使用</td><td>不使用</td></tr><tr><td>大数目的不同值</td><td>不使用</td><td>使用</td></tr><tr><td>频繁更新的列</td><td>不使用</td><td>使用</td></tr><tr><td>外键列</td><td>使用</td><td>使用</td></tr><tr><td>主键列</td><td>使用</td><td>使用</td></tr><tr><td>频繁修改索引列</td><td>不使用</td><td>使用</td></tr></tbody></table><h5 id="②、-索引不会包含有NULL值的列"><a href="#②、-索引不会包含有NULL值的列" class="headerlink" title="②、 索引不会包含有NULL值的列"></a><strong>②、 索引不会包含有NULL值的列</strong></h5><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><h5 id="③、使用短索引"><a href="#③、使用短索引" class="headerlink" title="③、使用短索引"></a><strong>③、使用短索引</strong></h5><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><h5 id="④、-索引列排序"><a href="#④、-索引列排序" class="headerlink" title="④、 索引列排序"></a><strong>④、 索引列排序</strong></h5><p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><h5 id="⑤、-like语句操作"><a href="#⑤、-like语句操作" class="headerlink" title="⑤、 like语句操作"></a><strong>⑤、 like语句操作</strong></h5><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p><h5 id="⑥、-不要在列上进行运算"><a href="#⑥、-不要在列上进行运算" class="headerlink" title="⑥、 不要在列上进行运算"></a><strong>⑥、 不要在列上进行运算</strong></h5><p>例如：select <em> from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select </em> from users where adddate&lt;’2007-01-01′。</p><h3 id="11、硬件优化"><a href="#11、硬件优化" class="headerlink" title="11、硬件优化"></a><strong>11、硬件优化</strong></h3><p><img src="C/images/MySQL优化/6.gif" alt=""></p><h4 id="从图上可以看到基本上每种设备都有两个指标："><a href="#从图上可以看到基本上每种设备都有两个指标：" class="headerlink" title="从图上可以看到基本上每种设备都有两个指标："></a><strong>从图上可以看到基本上每种设备都有两个指标：</strong></h4><p>延时（响应时间）：表示硬件的突发处理能力；</p><p>带宽（吞吐量）：代表硬件持续处理能力。</p><h4 id="从上图可以看出，计算机系统硬件性能从高到代依次为："><a href="#从上图可以看出，计算机系统硬件性能从高到代依次为：" class="headerlink" title="从上图可以看出，计算机系统硬件性能从高到代依次为："></a><strong>从上图可以看出，计算机系统硬件性能从高到代依次为：</strong></h4><p>CPU——Cache(L1-L2-L3)——内存——SSD硬盘——网络——硬盘</p><p>由于SSD硬盘还处于快速发展阶段，所以本文的内容不涉及SSD相关应用系统。</p><h4 id="根据数据库知识，我们可以列出每种硬件主要的工作内容："><a href="#根据数据库知识，我们可以列出每种硬件主要的工作内容：" class="headerlink" title="根据数据库知识，我们可以列出每种硬件主要的工作内容："></a><strong>根据数据库知识，我们可以列出每种硬件主要的工作内容：</strong></h4><p>CPU及内存：缓存数据访问、比较、排序、事务检测、SQL解析、函数或逻辑运算；</p><p>网络：结果数据传输、SQL请求、远程数据库访问（dblink）；</p><p>硬盘：数据访问、数据写入、日志记录、<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="noopener">大数据</a>量排序、大表连接。</p><h4 id="性能基本优化法则："><a href="#性能基本优化法则：" class="headerlink" title="性能基本优化法则："></a><strong>性能基本优化法则：</strong></h4><p><img src="/images/MySQL优化/7.gif" alt=""></p><p><strong>优化法则归纳为5个层次：</strong></p><p>1、  减少数据访问（减少磁盘访问）</p><p>2、  返回更少数据（减少网络传输或磁盘访问）</p><p>3、  减少交互次数（减少网络传输）</p><p>4、  减少服务器CPU开销（减少CPU及内存开销）</p><p>5、  利用更多资源（增加资源）</p><p> 由于每一层优化法则都是解决其对应硬件的性能问题，所以带来的性能提升比例也不一样。传统数据库系统设计是也是尽可能对低速设备提供优化方法，因此针对低速设备问题的可优化手段也更多，优化成本也更低。我们任何一个SQL的性能优化都应该按这个规则由上到下来诊断问题并提出解决方案，而不应该首先想到的是增加资源解决问题。</p><h4 id="以下是每个优化法则层级对应优化效果及成本经验参考："><a href="#以下是每个优化法则层级对应优化效果及成本经验参考：" class="headerlink" title="以下是每个优化法则层级对应优化效果及成本经验参考："></a><strong>以下是每个优化法则层级对应优化效果及成本经验参考：</strong></h4><table><thead><tr><th><strong>优化法则</strong></th><th><strong>性能提升效果</strong></th><th><strong>优化成本</strong></th></tr></thead><tbody><tr><td>减少数据访问</td><td>1~1000</td><td>低</td></tr><tr><td>返回更少数据</td><td>1~100</td><td>低</td></tr><tr><td>减少交互次数</td><td>1~20</td><td>低</td></tr><tr><td>减少服务器CPU开销</td><td>1~5</td><td>低</td></tr><tr><td>利用更多资源</td><td>@~10</td><td>高</td></tr></tbody></table><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h3><p>分库/分表实现参考：<a href="https://www.jianshu.com/u/138209947f2b" target="_blank" rel="noopener">codingBoyJack</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trinity调度延迟解决方法</title>
      <link href="/2019/04/09/trinity-diao-du-yan-chi-jie-jue-fang-fa/"/>
      <url>/2019/04/09/trinity-diao-du-yan-chi-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>1、查询各表占用的空间</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>   relname <span class="token keyword">as</span> <span class="token string">"Table"</span><span class="token punctuation">,</span>   pg_size_pretty<span class="token punctuation">(</span>pg_total_relation_size<span class="token punctuation">(</span>relid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">As</span> <span class="token string">"Size"</span><span class="token punctuation">,</span>   pg_size_pretty<span class="token punctuation">(</span>pg_total_relation_size<span class="token punctuation">(</span>relid<span class="token punctuation">)</span> <span class="token operator">-</span> pg_relation_size<span class="token punctuation">(</span>relid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">"External Size"</span><span class="token keyword">FROM</span> pg_catalog<span class="token punctuation">.</span>pg_statio_user_tables <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> pg_total_relation_size<span class="token punctuation">(</span>relid<span class="token punctuation">)</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>2、需要维护的table</p><pre class=" language-sql"><code class="language-sql">task<span class="token punctuation">,</span> taskdependencyrule<span class="token punctuation">,</span> jobexecution<span class="token punctuation">,</span> jobexecutionschedule<span class="token punctuation">,</span> jobtxdate</code></pre><p>3、执行vacuum操作</p><p><img src="/images/Trinity_vacuum/1.jpg" alt=""></p><p>右键需要维护的table-&gt;选择Maintenance-&gt;ANALYZE-&gt;ok</p><p><img src="/images/Trinity_vacuum/2.jpg" alt=""></p><p>再选择Vacuum-&gt;选择full-&gt;ok-&gt;REINDEX-&gt;ok</p><p><img src="/images/Trinity_vacuum/3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Trinity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ETL </tag>
            
            <tag> Trinity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建HDP集群报OPEN SSL问题解决方法</title>
      <link href="/2019/03/27/open-ssl-bao-cuo/"/>
      <url>/2019/03/27/open-ssl-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>报错：</p><pre class=" language-shell"><code class="language-shell">ERROR 2015-09-23 09:47:07,402 NetUtil.py:77 - [Errno 8] _ssl.c:492: EOF occurred in violation of protocolERROR 2015-09-23 09:47:07,402 NetUtil.py:78 - SSLError: Failed to connect. Please check openssl library versions.Refer to: https://bugzilla.redhat.com/show_bug.cgi?id=1022468 for more details.WARNING 2015-09-23 09:47:07,402 NetUtil.py:105 - Server at https://test.org:8440is not reachable, sleeping for 10 seconds...WARNING 2015-09-23 09:47:07,402 NetUtil.py:105 - Server at https://test.org:8440is not reachable, sleeping for 10 seconds...INFO 2015-09-23 09:47:14,746 main.py:74 - loglevel=logging.INFOINFO 2015-09-23 09:47:14,746 main.py:74 - loglevel=logging.INFOINFO 2015-09-23 09:47:17,403 NetUtil.py:59 - Connecting to https://test.org:8440/caWARNING 2015-09-23 09:47:17,404 NetUtil.py:82 - Failed to connect to https://test.org:8440/ca due to [Errno 111] Connection refusedWARNING 2015-09-23 09:47:17,404 NetUtil.py:105 - Server at https://test.org:8440is not reachable, sleeping for 10 seconds...WARNING 2015-09-23 09:47:17,404 NetUtil.py:105 - Server at https://test.org:8440is not reachable, sleeping for 10 seconds...ERROR 2015-09-23 09:47:19,780 main.py:315 - Fatal exception occurred:</code></pre><p>解决方法：</p><pre class=" language-shell"><code class="language-shell">vim /etc/ambari-agent/conf/ambari-agent.ini在[security]下添加force_https_protocol=PROTOCOL_TLSv1_2</code></pre><pre class=" language-shell"><code class="language-shell">vi /etc/python/cert-verification.cfg 在[https] 下添加verify=disable</code></pre><p>然后在Ambari界面点击retry进行重试操作</p>]]></content>
      
      
      <categories>
          
          <category> HDP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop问题 </tag>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS WEB UI上缺少datanode的问题解决方法</title>
      <link href="/2019/03/19/web-ui-shang-que-shao-datanode/"/>
      <url>/2019/03/19/web-ui-shang-que-shao-datanode/</url>
      
        <content type="html"><![CDATA[<h2 id="1、集群结构"><a href="#1、集群结构" class="headerlink" title="1、集群结构"></a>1、集群结构</h2><pre class=" language-sh"><code class="language-sh">192.168.0.60 host0192.168.0.61 host1192.168.0.62 host2192.168.0.63 host3192.168.0.64 host4</code></pre><h2 id="2、问题状况"><a href="#2、问题状况" class="headerlink" title="2、问题状况"></a>2、问题状况</h2><pre class=" language-sh"><code class="language-sh">#HDFS上显示存活的datanode个数为4个#HDFS WEB UI上显示的datanode个数为三个#缺少host4节点的datanode</code></pre><h2 id="3、问题解决思路"><a href="#3、问题解决思路" class="headerlink" title="3、问题解决思路"></a>3、问题解决思路</h2><pre class=" language-sh"><code class="language-sh">1、检查namenode与host4是否可以ping通2、如果不可以ping通，检查host4上的hosts文件，以及网络文件配置3、如果可以ping通，则检查host4当前的ip地址，有可能在免密配置完成后，重启主机，ip发生变化，此时192.168.168.0.64的地址仍然可以ping通，但是服务却不能连接，因此会导致在WEB UI上无法显示datanode，只需要修改网络配置文件，设置为静态IP即可，然后重启network。4、停止Hadoop所有服务，然后重启Hadoop集群，即可在WEB UI上查看到host4的datanode信息。</code></pre>]]></content>
      
      
      <categories>
          
          <category> HDP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop问题 </tag>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splice Engine历史拉链测试总结</title>
      <link href="/2019/03/19/splice-engine-li-shi-la-lian-ce-shi-zong-jie/"/>
      <url>/2019/03/19/splice-engine-li-shi-la-lian-ce-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="SM学习总结"><a href="#SM学习总结" class="headerlink" title="SM学习总结"></a>SM学习总结</h1><h2 id="基本环境参数"><a href="#基本环境参数" class="headerlink" title="基本环境参数"></a>基本环境参数</h2><p>Splice.olap.shuffle.partitions=1200</p><p>Dsplice.spark.yarn.executor.memoryOverhead=6144</p><p>Dsplice.spark.executor.memory=10g</p><p>splice.olap_server.external=true</p><p>splice.olap_server.memory=20480</p><p>HBASE_HEAPSIZE=20480</p><p>splice.splitBlockSize=32108864</p><h2 id="1、设置splice-olap-shuffle-partitions"><a href="#1、设置splice-olap-shuffle-partitions" class="headerlink" title="1、设置splice.olap.shuffle.partitions"></a>1、设置splice.olap.shuffle.partitions</h2><p>在 hbase的 custom hbase-site中添加splice.olap.shuffle.partitions=400，400数值可进行修改，400是一个相对稳妥的数值，该参数影响在<strong>shuffle</strong>过程中分区的个数，从而影响<strong>task</strong>的数量，如下是在测试10G数据时设置400和1200的参数运行效果：</p><p>​                                        <strong>10G结果对比</strong></p><table><thead><tr><th style="text-align:center">比较内容</th><th style="text-align:center">400</th><th style="text-align:center">1200</th></tr></thead><tbody><tr><td style="text-align:center">Split</td><td style="text-align:center"><strong>381s</strong></td><td style="text-align:center"><strong>343s</strong></td></tr><tr><td style="text-align:center">Minor compaction</td><td style="text-align:center">0s</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">Major compaction</td><td style="text-align:center">0s</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">闭链</td><td style="text-align:center"><strong>365s</strong></td><td style="text-align:center"><strong>325s</strong></td></tr><tr><td style="text-align:center">Minor compaction</td><td style="text-align:center">152s(24个)</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">Major compaction</td><td style="text-align:center">0s</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">开链</td><td style="text-align:center"><strong>105s</strong></td><td style="text-align:center"><strong>131s</strong></td></tr><tr><td style="text-align:center">Minor compaction</td><td style="text-align:center">0s</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">Major compaction</td><td style="text-align:center">0s</td><td style="text-align:center">0s</td></tr><tr><td style="text-align:center">总计</td><td style="text-align:center"><strong>851s</strong></td><td style="text-align:center"><strong>793s</strong></td></tr></tbody></table><p>​                                        <strong>10G测试结果</strong></p><table><thead><tr><th style="text-align:center">比较内容</th><th style="text-align:center">SM2.7.0.1907 partitions=400</th><th style="text-align:center">SM2.7.0.1907 partitions=600</th><th style="text-align:center">SM2.7.0.1907 partitions=1200</th></tr></thead><tbody><tr><td style="text-align:center">SPLIT</td><td style="text-align:center">123.986s</td><td style="text-align:center">109.756s</td><td style="text-align:center">109.925s</td></tr><tr><td style="text-align:center">闭链</td><td style="text-align:center">64.074s</td><td style="text-align:center">54.260s</td><td style="text-align:center">53.399s</td></tr><tr><td style="text-align:center">开链</td><td style="text-align:center">57.084s</td><td style="text-align:center">55.067s</td><td style="text-align:center">55.086s</td></tr><tr><td style="text-align:center">总计</td><td style="text-align:center">245.126s</td><td style="text-align:center">219.083s</td><td style="text-align:center">218.41s</td></tr></tbody></table><p>适量的设置该参数可以提升运行速度，但是过度设置splice.olap.shuffle.partitions参数不会减少运行时间反而会增加运行时间，所以该参数需要多次尝试修改，并且针对不同的数据量设置的大小也会不一样。</p><h2 id="2、创建表的字段类型选择问题"><a href="#2、创建表的字段类型选择问题" class="headerlink" title="2、创建表的字段类型选择问题"></a>2、创建表的字段类型选择问题</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> T_TELLER_ROLES_EXT_0214<span class="token punctuation">(</span>    ID            <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    STAFF_ID     <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    ROLE_ID        <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>尽量避免使用VARCHAR() 类型，在进行字段的比较时速度较慢。</p><p><strong>目前还使用的VARCHAR()类型，下一步尝试使用数字类型。</strong></p><h2 id="3、修改splice-splitBlockSize"><a href="#3、修改splice-splitBlockSize" class="headerlink" title="3、修改splice.splitBlockSize"></a>3、修改splice.splitBlockSize</h2><p>该参数影响使用多少个task从磁盘中读取数据，默认是<strong>67108864</strong>，可设置为<strong>32108864</strong>，具体大小还需要针对不同的运行情况，建议不要修改。</p><h2 id="4、insert-语句的编写"><a href="#4、insert-语句的编写" class="headerlink" title="4、insert 语句的编写"></a>4、insert 语句的编写</h2><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">#第一种</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> T_TELLER_ROLES_ADD <span class="token comment" spellcheck="true">--splice-properties bulkImportDirectory='/data/poc/HIS', useSpark=true, skipSampling=false</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_TELLER_ROLES_EXT_0215 <span class="token keyword">EXCEPT</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_TELLER_ROLES_EXT_0214<span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">#第二种</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> T_TELLER_ROLES_ADD <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_TELLER_ROLES_EXT_0215 <span class="token keyword">EXCEPT</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_TELLER_ROLES_EXT_0214<span class="token punctuation">;</span></code></pre><p>第一种是使用SM <strong>bulk load</strong>的方式向表中插入数据，参数bulkImportDirectory指的是SM有读写权限的文件夹，用于保存运行日志，其余参数可在官方文档中有详细解释。</p><h2 id="5、Error-resin-resin-U"><a href="#5、Error-resin-resin-U" class="headerlink" title="5、Error resin resin.U"></a>5、Error resin resin.U</h2><p>这个问题指的是资源使用已满，需要重启HBase，这个目前算是个<strong>BUG</strong>，在<strong>1905</strong>版本以后修复了。</p><h2 id="6、查询不到表的BUG"><a href="#6、查询不到表的BUG" class="headerlink" title="6、查询不到表的BUG"></a>6、查询不到表的BUG</h2><p>在创建表后，使用 show tables 无法查询到表的信息，但是可以对表进行操作，这个问题是系统缓存的问题，重启shell客户端，重新进行创建表即可。</p><h2 id="7、官网参数的修改"><a href="#7、官网参数的修改" class="headerlink" title="7、官网参数的修改"></a>7、官网参数的修改</h2><p><strong>官网参数为：</strong></p><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">数值</th></tr></thead><tbody><tr><td style="text-align:center">hbase.hstore.defaultengine.compactor</td><td style="text-align:center">com.splicemachine.compactions.SpliceDefaultCompactor</td></tr><tr><td style="text-align:center">hbase.hstore.defaultengine.compactionpolicy</td><td style="text-align:center">com.splicemachine.compactions.SpliceDefaultCompactionPolicy</td></tr></tbody></table><p><strong>修改后：</strong></p><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">数值</th></tr></thead><tbody><tr><td style="text-align:center">hbase.hstore.defaultengine.compactor<strong>.class</strong></td><td style="text-align:center">com.splicemachine.compactions.SpliceDefaultCompactor</td></tr><tr><td style="text-align:center">hbase.hstore.defaultengine.compactionpolicy<strong>.class</strong></td><td style="text-align:center">com.splicemachine.compactions.SpliceDefaultCompactionPolicy</td></tr></tbody></table><h2 id="8、如下参数谨慎设置"><a href="#8、如下参数谨慎设置" class="headerlink" title="8、如下参数谨慎设置"></a>8、如下参数谨慎设置</h2><p>hbase.hstore.compaction.max.size设置为Long.MAX_VALUE，设置完之后SM服务会无法启动，所以该参数<strong>不要修改</strong>变动。</p><h2 id="9、HBase自身的问题"><a href="#9、HBase自身的问题" class="headerlink" title="9、HBase自身的问题"></a>9、HBase自身的问题</h2><p><strong>错误一：</strong>So there may be a TCP socket connection left open in CLOSE_WAIT state. For more details check <a href="https://issues.apache.org/jira/browse/HBASE-9393" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/HBASE-9393</a><br>后面的URL指向这个问题的解决方式</p><h2 id="10、Hmaster与regionserver"><a href="#10、Hmaster与regionserver" class="headerlink" title="10、Hmaster与regionserver"></a>10、Hmaster与regionserver</h2><p>配置集群时，Hmaster与regionserver服务不要放在同一节点上，splice服务要与regionserver放在同一节点上。</p><h2 id="11、删除表后，在hbase中不会删除，而是会在原来表的位置打标记。"><a href="#11、删除表后，在hbase中不会删除，而是会在原来表的位置打标记。" class="headerlink" title="11、删除表后，在hbase中不会删除，而是会在原来表的位置打标记。"></a>11、删除表后，在hbase中不会删除，而是会在原来表的位置打标记。</h2><p>运行CALL SYSCS_UTIL.VACUUM();删除已经被删除的表</p><p>详细介绍：<a href="https://doc.splicemachine.com/sqlref_sysprocs_vacuum.html" target="_blank" rel="noopener">https://doc.splicemachine.com/sqlref_sysprocs_vacuum.html</a></p><p>在删除一张表并且重新创建一张与原来相同表名的表需要在创建表之前执行该命令。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">Drop</span> <span class="token keyword">table</span> A<span class="token punctuation">;</span><span class="token keyword">CALL</span> SYSCS_UTIL<span class="token punctuation">.</span>VACUUM<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">Create</span> <span class="token keyword">table</span> A<span class="token punctuation">;</span></code></pre><h2 id="12、增加spark的执行内存"><a href="#12、增加spark的执行内存" class="headerlink" title="12、增加spark的执行内存"></a>12、增加spark的执行内存</h2><pre class=" language-shell"><code class="language-shell">Job aborted due to stage failure: Task 15 in stage 181.0 failed 4 times, most recent failure: Lost task 15.3 in stage 181.0 (TID 3633, master, executor 361): ExecutorLostFailure (executor 361 exited caused by one of the running tasks) Reason: Container killed by YARN for exceeding memory limits. 14.3 GB of 14 GB physical memory used. Consider boosting spark.yarn.executor.memoryOverhead.Driver stacktrace:</code></pre><p>当出现以上问题时，需要修改如下参数：</p><p>Dsplice.spark.yarn.executor.memoryOverhead=6144</p><p>Dsplice.spark.executor.memory=10g。</p><h2 id="13、修改HBASE-HEAPSIZE"><a href="#13、修改HBASE-HEAPSIZE" class="headerlink" title="13、修改HBASE_HEAPSIZE"></a>13、修改HBASE_HEAPSIZE</h2><p>官网建议将splice.olap_server.memory的大小设置和HMaster heap size的大小相同。</p><h2 id="14、其他优化参数"><a href="#14、其他优化参数" class="headerlink" title="14、其他优化参数"></a>14、其他优化参数</h2><h2 id="15、向Splice导入数据时注意事项"><a href="#15、向Splice导入数据时注意事项" class="headerlink" title="15、向Splice导入数据时注意事项"></a>15、向Splice导入数据时注意事项</h2><p>例：<strong>在所有导入数据的方法中</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">call</span> SYSCS_UTIL<span class="token punctuation">.</span>BULK_IMPORT_HFILE <span class="token punctuation">(</span>    schemaName<span class="token punctuation">,</span>    tableName<span class="token punctuation">,</span>    insertColumnList <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    fileName<span class="token punctuation">,</span>    columnDelimiter <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    characterDelimiter <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    timestampFormat <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    dateFormat <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    timeFormat <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    maxBadRecords<span class="token punctuation">,</span>    badRecordDirectory <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    oneLineRecords <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    <span class="token keyword">charset</span> <span class="token operator">|</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    bulkImportDirectory<span class="token punctuation">,</span>    skipSampling<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>bulkImportDirectory</strong>一定要将数据放在<strong>除一级目录</strong>之外的次级目录中，如/data/14g.csv或/data/poc/14g.csv等</p><p>在使用<strong>BULK_IMPORT_HFILE</strong>方法时需要修改如下参数：</p><pre class=" language-shell"><code class="language-shell">yarn.nodemanager.pmem-check-enabled=falseyarn.nodemanager.vmem-check-enabled=false</code></pre><h2 id="16、磁盘管理"><a href="#16、磁盘管理" class="headerlink" title="16、磁盘管理"></a>16、磁盘管理</h2><p>当磁盘空间到达阀值时，yarn会拒绝启动，默认阀值为90%，建议不要修改。</p><h2 id="17、Splice其他参数"><a href="#17、Splice其他参数" class="headerlink" title="17、Splice其他参数"></a>17、Splice其他参数</h2><h2 id="18、查询优化"><a href="#18、查询优化" class="headerlink" title="18、查询优化"></a>18、查询优化</h2>]]></content>
      
      
      <categories>
          
          <category> Splice Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Splice Engine优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yarn Register DNS 端口占用</title>
      <link href="/2019/01/29/yarn-register-dns/"/>
      <url>/2019/01/29/yarn-register-dns/</url>
      
        <content type="html"><![CDATA[<p>如果在安装时看到与YARN Registry DNS Bind Port相关的错误。可以参考以下步骤操作：</p><h2 id="1、打开Ambari管理界面并进入YARN管理界面"><a href="#1、打开Ambari管理界面并进入YARN管理界面" class="headerlink" title="1、打开Ambari管理界面并进入YARN管理界面"></a>1、打开Ambari管理界面并进入YARN管理界面</h2><p><img src="/images/yarn-register-dns1.png" alt="Alt text"></p><h2 id="2、点击CONFIGS，进入配置界面"><a href="#2、点击CONFIGS，进入配置界面" class="headerlink" title="2、点击CONFIGS，进入配置界面"></a>2、点击CONFIGS，进入配置界面</h2><p><img src="/images/yarn-register-dns2.png" alt="Alt text"></p><h2 id="3、点击ADVANCED进入高级设置中修改DNS端口号"><a href="#3、点击ADVANCED进入高级设置中修改DNS端口号" class="headerlink" title="3、点击ADVANCED进入高级设置中修改DNS端口号"></a>3、点击ADVANCED进入高级设置中修改DNS端口号</h2><p><img src="/images/yarn-register-dns3.png" alt="Alt text"></p><p><strong>将53修改成其他不被占用的端口即可</strong></p><h2 id="4、重启集群，YARN正常启动"><a href="#4、重启集群，YARN正常启动" class="headerlink" title="4、重启集群，YARN正常启动"></a>4、重启集群，YARN正常启动</h2><p>参考文献：<a href="https://community.hortonworks.com/articles/225841/yarn-registry-dns-port-conflict-issue.html" target="_blank" rel="noopener">Hortonworks</a></p>]]></content>
      
      
      <categories>
          
          <category> HDP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop问题 </tag>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDP安装——基础环境配置</title>
      <link href="/2019/01/29/hdp-an-zhuang-ji-chu-pei-zhi/"/>
      <url>/2019/01/29/hdp-an-zhuang-ji-chu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h2><p><strong>注：安装centos7时，安装英文版，避免环境安装时报错</strong></p><table><thead><tr><th style="text-align:left"><strong>ambari</strong></th><th><strong><a href="http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/ambari-2.7.3.0-centos7.tar.gz" target="_blank" rel="noopener">http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/ambari-2.7.3.0-centos7.tar.gz</a></strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>HDP</strong></td><td><strong><a href="http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0/HDP-3.1.0.0-centos7-rpm.tar.gz" target="_blank" rel="noopener">http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0/HDP-3.1.0.0-centos7-rpm.tar.gz</a></strong></td></tr><tr><td style="text-align:left"><strong>HDP-UTILS</strong></td><td><strong><a href="http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gz" target="_blank" rel="noopener">http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gz</a></strong></td></tr><tr><td style="text-align:left"><strong>HDP-GPL</strong></td><td><strong><a href="http://public-repo-1.hortonworks.com/HDP-GPL/centos7/3.x/updates/3.1.0.0/HDP-GPL-3.1.0.0-centos7-gpl.tar.gz" target="_blank" rel="noopener">http://public-repo-1.hortonworks.com/HDP-GPL/centos7/3.x/updates/3.1.0.0/HDP-GPL-3.1.0.0-centos7-gpl.tar.gz</a></strong></td></tr></tbody></table><hr><h2 id="二、系统环境配置"><a href="#二、系统环境配置" class="headerlink" title="二、系统环境配置"></a>二、系统环境配置</h2><p><strong>所有操作都是root用户</strong></p><h3 id="1、修改主机名"><a href="#1、修改主机名" class="headerlink" title="1、修改主机名"></a>1、修改主机名</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上vim /etc/hostname</code></pre><pre class=" language-shell"><code class="language-shell">master01 #主机名称</code></pre><h3 id="2、修改网络"><a href="#2、修改网络" class="headerlink" title="2、修改网络"></a>2、修改网络</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上vim /etc/sysconfig/network-scripts/ifcfg-enp0s31f6 #ifcfg-enp0s31f6 为网卡名称</code></pre><pre class=" language-shell"><code class="language-shell">BOOTPROTO="static"          # 使用静态IP地址，默认为dhcpIPADDR="192.168.0.80"       # 设置的静态IP地址NETMASK="255.255.255.0"     # 子网掩码GATEWAY="192.168.0.1"       # 网关地址DNS1="8.8.8.8"               # DNS服务器ONBOOT="yes"                 #是否开机启用</code></pre><h3 id="3、配置hosts文件"><a href="#3、配置hosts文件" class="headerlink" title="3、配置hosts文件"></a>3、配置hosts文件</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上vi /etc/hosts</code></pre><pre class=" language-shell"><code class="language-shell">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.0.80 master01192.168.0.81 node01192.168.0.82 node02</code></pre><h3 id="4、关闭防火墙"><a href="#4、关闭防火墙" class="headerlink" title="4、关闭防火墙"></a>4、关闭防火墙</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上systemctl disable firewalldsystemctl stop firewalld</code></pre><h3 id="5、设置SSH免密登陆"><a href="#5、设置SSH免密登陆" class="headerlink" title="5、设置SSH免密登陆"></a>5、设置SSH免密登陆</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上ssh-keygen 三下回车ssh-copy-id master01ssh-copy-id node01ssh-copy-id node02</code></pre><h3 id="6、检查DNS和NSCD"><a href="#6、检查DNS和NSCD" class="headerlink" title="6、检查DNS和NSCD"></a>6、检查DNS和NSCD</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上setenforce 0    #临时设置 重启失效</code></pre><pre class=" language-shell"><code class="language-shell">#在所有机器上vim /etc/selinux/config    #永久有效 需重启机器SELINUX=disabled</code></pre><pre class=" language-shell"><code class="language-shell">#在所有机器上umask 0022    #临时设置 重启失效echo umask 0022 >> /etc/profile    #永久有效 重启生效umask #检查当前机器的umask码</code></pre><h3 id="7、修改文件打开限制"><a href="#7、修改文件打开限制" class="headerlink" title="7、修改文件打开限制"></a>7、修改文件打开限制</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上vim /etc/security/limits.conf#在文件最后# End of file* soft nofile 65536* hard nofile 65536* soft nproc 131072* hard nproc 131072</code></pre><h3 id="8、同步时钟"><a href="#8、同步时钟" class="headerlink" title="8、同步时钟"></a>8、同步时钟</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeyum -y install ntp#在主服务器上vim /etc/ntp.conf#在文件中配置restrict default nomodify notrap nopeer noqueryserver 127.127.1.0fudge 127.127.1.0 stratum 10#在子节点中crontab -e0-59/10 * * * * /usr/sbin/ntpdate master01#在所有节点启动服务systemctl start ntpdsystemctl enable ntpd</code></pre><h3 id="9、安装JDK"><a href="#9、安装JDK" class="headerlink" title="9、安装JDK"></a>9、安装JDK</h3><h4 id="Ⅰ、先安装openjdk"><a href="#Ⅰ、先安装openjdk" class="headerlink" title="Ⅰ、先安装openjdk"></a>Ⅰ、<strong>先安装openjdk</strong></h4><p>​            安装openjdk解决包依赖的问题</p><pre class=" language-shell"><code class="language-shell">#在所有机器上yum -y install java</code></pre><h4 id="Ⅱ、卸载openjdk"><a href="#Ⅱ、卸载openjdk" class="headerlink" title="Ⅱ、卸载openjdk"></a>Ⅱ、卸载openjdk</h4><p>​        卸载jdk包，但是保留依赖包</p><pre class=" language-shell"><code class="language-shell">#在所有机器上rpm -qa|grep javayum remove java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64</code></pre><h4 id="Ⅲ、安装开源JDK"><a href="#Ⅲ、安装开源JDK" class="headerlink" title="Ⅲ、安装开源JDK"></a>Ⅲ、安装开源JDK</h4><pre class=" language-shell"><code class="language-shell">#在所有机器上#下载jdkwget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm?AuthParam=1548732196_c3d078fb7f78308027532d04a26b4612#重命名mv jdk-8u201-linux-x64.rpm?AuthParam=1548732196_c3d078fb7f78308027532d04a26b4612 jdk-8u201-linux-x64.rpm#安装jdkrpm -ivh jdk-8u201-linux-x64.rpm#检查jdk版本java -versionjava version "1.8.0_201"Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)#修改配置文件export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar export PATH=$JAVA_HOME/bin:$PATH</code></pre><h3 id="10、安装MySQL"><a href="#10、安装MySQL" class="headerlink" title="10、安装MySQL"></a>10、安装MySQL</h3><p><strong>默认是PostgreSQL，但是在生产环境中不建议使用，所以安装mysql或其他，mysql安装在主节点上，如有需要可以安装在其他节点上</strong></p><h4 id="Ⅰ、卸载原来的MySQL"><a href="#Ⅰ、卸载原来的MySQL" class="headerlink" title="Ⅰ、卸载原来的MySQL"></a>Ⅰ、卸载原来的MySQL</h4><pre class=" language-shell"><code class="language-shell">rpm -qa|grep -i mysql #查看是否安装mysqlyum remove …     #卸载mysql所有内容find / -name mysql    #查找mysql所有文件位置rm -rf /var/lib/mysql…    #删除mysql相关文件rm -rf /var/log/mysql.log #删除该日志文件</code></pre><h4 id="Ⅱ、下载安装MySQL5-6"><a href="#Ⅱ、下载安装MySQL5-6" class="headerlink" title="Ⅱ、下载安装MySQL5.6"></a>Ⅱ、下载安装MySQL5.6</h4><pre class=" language-shell"><code class="language-shell">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-server    #安装mysqlsystemctl start mysqld    #启动mysqlsystemctl enable mysqld    #开机启动</code></pre><h4 id="Ⅲ、修改默认密码"><a href="#Ⅲ、修改默认密码" class="headerlink" title="Ⅲ、修改默认密码"></a>Ⅲ、修改默认密码</h4><pre class=" language-shell"><code class="language-shell">mysql -u root -p (无密码)use mysqlselect host,user,password from user;delete from user where user='';update user set host='%' where user='localhost';    #(如果无user=localhost 可不执行这条命令)update user set password=PASSWORD('123456') where host='%'    #(这条命令是根据上条执行)update user set password=PASSWORD('123456') where user='root' and host='localhost';update user set password=PASSWORD('123456') where user='root' and host='master';    #(可选操作，master01为主机名)grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;    #(远程连接数据库权限设置)flush privileges;     #要刷新权限</code></pre><h2 id="三、修改yum源，实现离线安装"><a href="#三、修改yum源，实现离线安装" class="headerlink" title="三、修改yum源，实现离线安装"></a>三、修改yum源，实现离线安装</h2><h3 id="1、安装httpd"><a href="#1、安装httpd" class="headerlink" title="1、安装httpd"></a>1、安装httpd</h3><pre class=" language-shell"><code class="language-shell">#在master01上执行yum -y install httpdservice httpd restartsystemctl enable httpd</code></pre><h3 id="2、修改安装文件位置"><a href="#2、修改安装文件位置" class="headerlink" title="2、修改安装文件位置"></a>2、修改安装文件位置</h3><pre class=" language-shell"><code class="language-shell">#在master01上执行cd /var/www/html/mkdir ambari#解压文件tar -xvzf ambari-2.7.3.0-centos7.tar.gztar -xvzf HDP-3.1.0.0-centos7-rpm.tar.gztar -xvzf HDP-GPL-3.1.0.0-centos7-gpl.tar.gztar -xvzf HDP-UTILS-1.1.0.22-centos7.tar.gz#打开http://192.168.0.80/ambari 查看是否有结果</code></pre><h3 id="3、制作本地源"><a href="#3、制作本地源" class="headerlink" title="3、制作本地源"></a>3、制作本地源</h3><pre class=" language-shell"><code class="language-shell">#在master01上执行#在/var/www/html/ambari目录下创建yum源yum install yum-utils createrepo yum-plugin-priorities -ycreaterepo  ./</code></pre><pre class=" language-shell"><code class="language-shell">#在master01上执行#修改ambari安装包源配置cd /var/www/html/ambari/ambari/centos7/2.7.3.0-139vim ambari.repo#VERSION_NUMBER=2.7.3.0-139[ambari-2.7.3.0]#json.url = http://public-repo-1.hortonworks.com/HDP/hdp_urlinfo.jsonname=ambari Version - ambari-2.7.3.0baseurl=http://192.168.0.80/ambari/ambari/centos7/2.7.3.0-139gpgcheck=1gpgkey=http://192.168.0.80/ambari/ambari/centos7/2.7.3.0-139/RPM-GPG-KEY/RPM-GPG-KEY-Jenkinsenabled=1priority=1</code></pre><pre class=" language-shell"><code class="language-shell">#在master01上执行#修改HDP配置文件cd /var/www/html/ambari/HDP/centos7/3.1.0.0-78vim hdp.repo#VERSION_NUMBER=3.1.0.0-78[HDP-3.1.0.0]name=HDP Version - HDP-3.1.0.0baseurl=http://192.168.0.80/ambari/HDP/centos7/3.1.0.0-78gpgcheck=1gpgkey=http://192.168.0.80/ambari/HDP/centos7/3.1.0.0-78/RPM-GPG-KEY/RPM-GPG-KEY-Jenkinsenabled=1priority=1[HDP-UTILS-1.1.0.22]name=HDP-UTILS Version - HDP-UTILS-1.1.0.22baseurl=http://192.168.0.80/ambari/HDP-UTILS/centos7/1.1.0.22gpgcheck=1gpgkey=http://192.168.0.80/ambari/HDP-UTILS/centos7/1.1.0.22/RPM-GPG-KEY/RPM-GPG-KEY-Jenkinsenabled=1priority=1</code></pre><h3 id="4、将repo文件辅助到YUM库"><a href="#4、将repo文件辅助到YUM库" class="headerlink" title="4、将repo文件辅助到YUM库"></a>4、将repo文件辅助到YUM库</h3><pre class=" language-shell"><code class="language-shell">#在master01上执行cp /var/www/html/ambari/ambari/centos7/2.7.3.0-139/ambari.repo /etc/yum.repos.d/cp /var/www/html/ambari/HDP/centos7/3.1.0.0-78/hdp.repo /etc/yum.repos.d/</code></pre><h3 id="5、将文件拷贝到子节点"><a href="#5、将文件拷贝到子节点" class="headerlink" title="5、将文件拷贝到子节点"></a>5、将文件拷贝到子节点</h3><pre class=" language-shell"><code class="language-shell">#在master01上执行scp /etc/yum.repos.d/ambari.repo node01:/etc/yum.repos.d/scp /etc/yum.repos.d/ambari.repo node02:/etc/yum.repos.d/scp /etc/yum.repos.d/hdp.repo node01:/etc/yum.repos.d/scp /etc/yum.repos.d/hdp.repo node02:/etc/yum.repos.d/</code></pre><h3 id="6、重新设置YUM缓存"><a href="#6、重新设置YUM缓存" class="headerlink" title="6、重新设置YUM缓存"></a>6、重新设置YUM缓存</h3><pre class=" language-shell"><code class="language-shell">#在所有机器上执行yum clean allyum makecache</code></pre><h2 id="四、安装ambari-server"><a href="#四、安装ambari-server" class="headerlink" title="四、安装ambari-server"></a>四、安装ambari-server</h2><h3 id="1、在MySQL中创建用户和数据库"><a href="#1、在MySQL中创建用户和数据库" class="headerlink" title="1、在MySQL中创建用户和数据库"></a>1、在MySQL中创建用户和数据库</h3><pre class=" language-shell"><code class="language-shell">#根据安装软件需要自己选择要创建的数据库和用户CREATE DATABASE ambari;  use ambari;  CREATE USER 'ambari'@'%' IDENTIFIED BY '123456';  GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'%';  CREATE USER 'ambari'@'localhost' IDENTIFIED BY '123456';  GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'localhost';  CREATE USER 'ambari'@'master01' IDENTIFIED BY '123456';  GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'master01';  FLUSH PRIVILEGES;  CREATE DATABASE hive;  use hive;  CREATE USER 'hive'@'%' IDENTIFIED BY 'hive';  GRANT ALL PRIVILEGES ON *.* TO 'hive'@'%';  CREATE USER 'hive'@'localhost' IDENTIFIED BY 'hive';  GRANT ALL PRIVILEGES ON *.* TO 'hive'@'localhost';  CREATE USER 'hive'@'master01' IDENTIFIED BY 'hive';  GRANT ALL PRIVILEGES ON *.* TO 'hive'@'master01';  FLUSH PRIVILEGES;  CREATE DATABASE oozie;  use oozie;  CREATE USER 'oozie'@'%' IDENTIFIED BY 'oozie';  GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'%';  CREATE USER 'oozie'@'localhost' IDENTIFIED BY 'oozie';  GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'localhost';  CREATE USER 'oozie'@'master01' IDENTIFIED BY 'oozie';  GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'master01';  FLUSH PRIVILEGES;  </code></pre><h3 id="2、将jar包放入环境"><a href="#2、将jar包放入环境" class="headerlink" title="2、将jar包放入环境"></a>2、将jar包放入环境</h3><pre class=" language-shell"><code class="language-shell">#下载mysql-connector-java-5.1.47.tar.gzcd /datawget https://cdn.mysql.com//Downloads/Connector-J/mysql-connector-java-5.1.47.tar.gztar -xvzf mysql-connector-java-5.1.47.tar.gzcp /data/mysql-connector-java-5.1.47/mysql-connector-java-5.1.47* /usr/share/java/cd /usr/share/java/mv mysql-connector-java-5.1.47.jar mysql-connector-java.jarcp /usr/share/java/mysql-connector-java.jar /var/lib/ambari-server/resources/mysql-jdbc-driver.jar</code></pre><h3 id="3、初始化ambari-server并启动"><a href="#3、初始化ambari-server并启动" class="headerlink" title="3、初始化ambari-server并启动"></a>3、初始化ambari-server并启动</h3><pre class=" language-shell"><code class="language-shell">#初始化ambari-server setup --jdbc-db=mysql --jdbc-driver=/usr/share/java/mysql-connector-java.jar#配置ambariambari-server setup#所有选项选择y即可，当遇到如下选项时#配置JDK环境Checking JDK...Do you want to change Oracle JDK [y/n] (n)? y[1] Oracle JDK 1.8 + Java Cryptography Extension (JCE) Policy Files 8[2] Oracle JDK 1.7 + Java Cryptography Extension (JCE) Policy Files 7[3] Custom JDK==============================================================================Enter choice (1): 3如果上面选择3自定义JDK,则需要设置JAVA_HOME。输入：/usr/java/jdk1.8.0_201-amd64#配置数据库Configuring database...Enter advanced database configuration [y/n] (n)? yConfiguring database...==============================================================================Choose one of the following options:[1] - PostgreSQL (Embedded)[2] - Oracle[3] - MySQL[4] - PostgreSQL[5] - Microsoft SQL Server (Tech Preview)[6] - SQL Anywhere==============================================================================Enter choice (3): 3#设置数据库的具体配置信息，根据实际情况输入，如果和括号内相同，则可以直接回车。如果想重命名，就输入。Hostname (localhost):Port (3306):Database name (ambari):Username (ambari):Enter Database Password (bigdata):    123456    #创建用户时设置的密码Re-Enter password: 123456</code></pre><p>检查mysql中是否有新建的表</p><pre class=" language-shell"><code class="language-shell">mysql -u root -p 123456use ambari;show tables;#如果表为空的话cd /var/lib/ambari-server/resources    #sql脚本位置myslq -u ambari -p 123456use ambari;source Ambari-DDL-MySQL-CREATE.sql;</code></pre><h3 id="4、错误处理"><a href="#4、错误处理" class="headerlink" title="4、错误处理"></a>4、错误处理</h3><p>如果出现错误，查看server日志，根据报错进行修改</p><pre class=" language-shell"><code class="language-shell">cat var/log/ambari-server/ambari-server.log</code></pre><p>也可以删除数据库重新配置</p><pre class=" language-shell"><code class="language-shell">ambari-server stopmysql -u root -p 123456drop database ambari;drop database hive;drop database oozie;#重新创建数据库</code></pre><h3 id="5、清除已经安装的包"><a href="#5、清除已经安装的包" class="headerlink" title="5、清除已经安装的包"></a>5、清除已经安装的包</h3><pre class=" language-shell"><code class="language-shell">#在ambari-server启动的状态下执行命令，清除已经安装的软件包python /usr/lib/python2.6/site-packages/ambari_agent/HostCleanup.py --silent</code></pre><h3 id="6、安装向导本地源库地址"><a href="#6、安装向导本地源库地址" class="headerlink" title="6、安装向导本地源库地址"></a>6、安装向导本地源库地址</h3><pre class=" language-shell"><code class="language-shell">#HDPhttp://192.168.0.80/ambari/HDP/centos7/3.1.0.0-78/#HDP-UTILShttp://192.168.0.80/ambari/HDP-UTILS/centos7/1.1.0.22/#HDP-GPLhttp://192.168.0.80/ambari/HDP-GPL/centos7/3.1.0.0-78/</code></pre>]]></content>
      
      
      <categories>
          
          <category> HDP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
            <tag> HDP安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
